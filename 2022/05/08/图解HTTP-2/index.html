<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>图解HTTP---2 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="4.返回结果的 HTTP 状态码 HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端 的处理是否正常、通知出现的错误等工作。让我们通过本章的学习， 好好了解一下状态码的工作机制。 4.1 状态码告知从服务器端返回的请求结果  状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结 果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出 现了错误。">
<meta property="og:type" content="article">
<meta property="og:title" content="图解HTTP---2">
<meta property="og:url" content="http://example.com/2022/05/08/%E5%9B%BE%E8%A7%A3HTTP-2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="4.返回结果的 HTTP 状态码 HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端 的处理是否正常、通知出现的错误等工作。让我们通过本章的学习， 好好了解一下状态码的工作机制。 4.1 状态码告知从服务器端返回的请求结果  状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结 果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出 现了错误。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/ee3a4b9c5456e8fc8f64642dc54d4f2f.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/b884be2c7304a2331d69702dd083a271.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/3c3967db36509f4ab11296f0f553bb2b.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/ad3c7fdc04077203b72a61140e7c47b6.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/ebfa27dd4ce57042cffd64e2b7b8bf58.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/c8e2b7669e12b9ebf399c805dbc2c866.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/40d7ef64e4b1f8eb9ce8bc2225bf8123.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/ed170f9245119dc3520a8652abe72c81.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/97506ad157dd71356f1229f0707f49cb.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/2d58cb7eafeb2c1c5696c293494d7f65.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/00c50b8ec40ffe2bdc4221938a68ad5d.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/d3c63a438022740bc32b362c928ab0a4.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/a627503d9d63f5e4cdfd85421b115770.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/9ae74a67e5b859b9bbefe3ffae679883.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/3d39f222d8aaa43661186787f6c2c7a5.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/19f69a7169e80253266bf6f59665a11c.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/fc1499bfba15b45e48fd8812faf150f9.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/d565a6b0df5fae6f64d0f551811821cc.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/20359195cbc0bd0c9547d41a5fbfd7b2.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/b1525971930c5895922682dd0e8607d6.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/61f1a4efe4062b5602586092ff49a5b4.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/f4a64de0494b096f0ba7eceedaf9881b.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/7b5dc1467f328da9b78803606be65a26.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/56d37833b9f302a857c4578eacd0d500.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/debf84030561c988029a028e9b252957.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/9f89f80c46b403e8aee89d9854b65caf.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/ae956476fc03a44076733adda11bd1a2.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/ceb683616ace47388b62a276fd72a3a0.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/39f8249a2bb68ca24cdf56b5985e8340.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/0aa2c8864ab435d68e96f045cbdc1e32.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/feda461972bb96693e37061231301b1a.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/a97c2fe50b4adee8739bb9af34893770.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/768b07b1f7416ce32f84737ac9c0aaba.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/f8e3cf840520acd6cfefe0f8c4f8c56c.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/75525a6aedde277c147e54a927d1be87.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/a2fc642e9f11af444196f4d8ea76a2fa.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/12885b891d82d69da4dd20b854cd2095.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/0bf6162d5d4eb140ac90094b607250d4.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/dfac4ebd1d390909779af9e3ef24ed40.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/1db173c70e9ecc5135c8581d520dd68a.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/5016d62b0a654838378984adf53bc12e.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/8e91a8c9dbff314ae8c3aa05ee3e2bbf.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/d2398f54b331b1b802aa433b87966dd3.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/477bc20c822cb09fc498d3b142781aa1.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/340b2d5267e9e0d2fe8c1ea46bded206.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/c17ef9a89e27c2e871bab6e78cf56bca.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/b20e86a813b374bd9e1de4426aa1fe32.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/c7f3b4f012330beb16f75eddcd8f717d.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/194eecc9c4e9a1870eb6f9acd67b56e2.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/1f4cd260db122a01388d540e1122a616.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/5b30c1d24faf0926d0d2d663e4661d1e.png">
<meta property="og:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/5d6f64aaa1323ad6bbe52d08f64b84c8.png">
<meta property="article:published_time" content="2022-05-08T04:54:17.473Z">
<meta property="article:modified_time" content="2022-05-08T04:54:55.142Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/ee3a4b9c5456e8fc8f64642dc54d4f2f.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-图解HTTP-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/08/%E5%9B%BE%E8%A7%A3HTTP-2/" class="article-date">
  <time class="dt-published" datetime="2022-05-08T04:54:17.473Z" itemprop="datePublished">2022-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      图解HTTP---2
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>4.返回结果的 HTTP 状态码</strong></p>
<p>HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端 的处理是否正常、通知出现的错误等工作。让我们通过本章的学习， 好好了解一下状态码的工作机制。</p>
<p><strong>4.1 状态码告知从服务器端返回的请求结果</strong> </p>
<p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结 果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出 现了错误。</p>
<span id="more"></span>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/ee3a4b9c5456e8fc8f64642dc54d4f2f.png" alt="ee3a4b9c5456e8fc8f64642dc54d4f2f.png"></p>
<p>状态码如 200 OK，以 3 位数字和原因短语组成。 数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种。</p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/b884be2c7304a2331d69702dd083a271.png" alt="b884be2c7304a2331d69702dd083a271.png"></p>
<p><strong>4.2 2XX 成功�</strong>�</p>
<p>2XX 的响应结果表明请求被正常处理了。 </p>
<p><strong>4.2.1 200 OK</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/3c3967db36509f4ab11296f0f553bb2b.png" alt="3c3967db36509f4ab11296f0f553bb2b.png"></strong></p>
<p>表示从客户端发来的请求在服务器端被正常处理了。 在响应报文内，随状态码一起返回的信息会因方法的不同而发生改 变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返 回；而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体 作为响应返回（即在响应中只返回首部，不会返回实体的主体部 分）。</p>
<p><strong>4.2.2 204 No Content</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/ad3c7fdc04077203b72a61140e7c47b6.png" alt="ad3c7fdc04077203b72a61140e7c47b6.png"></strong></p>
<p>        该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中 <strong>不含实体的主体部分</strong>。意思等同于请求执行成功，但是没有数据，浏览器不用刷新页面.也不用导向新的页面。如何理解这段话呢。还是通过例子来说明吧，假设页面上有个form，提交的url为http-204.htm，提交form，正常情况下，页面会跳转到http-204.htm，但是如果http-204.htm的相应的状态码是204，此时页面就不会发生转跳，还是停留在当前页面。另外对于a标签，如果链接的页面响应码为204，页面也不会发生跳转。</p>
<p>        所以对于一些提交到服务器处理的数据，只需要返回是否成功的情况下，可以考虑使用状态码204来作为返回信息，从而省掉多余的数据传输。</p>
<p><strong>4.2.3 206 Partial Content</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/ebfa27dd4ce57042cffd64e2b7b8bf58.png" alt="ebfa27dd4ce57042cffd64e2b7b8bf58.png"></strong></p>
<p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p>
<p><strong>4.3 3XX 重定向</strong> </p>
<p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请 求。</p>
<p>其中 301 和 302 都是用来进行页面重定向的，所以在说起这两个状态码区别之前，我们先说一说页面重定向。在网页重定向中，其实是指当访问了一个网页，启动跳转至新的网页页面。比如：当你在一个网站中反问个人中心页面，然而这时你并没有登录，于是后台作出重定向页面的反应；接下来你在用户登录页面进行登录操作，登录成功后自动跳转至个人中心页面。而这里使用了不同的重定向页面方式，根据不同的需求场景，开发者也会使用不同的重定向技术。</p>
<h2 id="301-永久重定向"><a href="#301-永久重定向" class="headerlink" title="301 永久重定向"></a><strong>301 永久重定向</strong></h2><p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应放回的若干 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p>
<p>301 最简单最常用的一个常见应该就是域名跳转了。比如，我们访问 <a target="_blank" rel="noopener" href="http://www.google.com/">http://www.google.com</a> 会自动跳转至 <a target="_blank" rel="noopener" href="https://www.google.com/">https://www.google.com</a> ，这一个访问过程是这样的：发送请求之后，服务器给你返回一个 301 状态码，并在 Response Header 中设置 Location 为<a target="_blank" rel="noopener" href="https://www.google.com/">https://www.google.com</a> ，浏览器收到这样的响应自动修改地址栏中的地址，继续访问新的地址。</p>
<p>注意：301 请求是可以缓存的，也就是说，用户下一次通过浏览器访问 <a target="_blank" rel="noopener" href="http://www.google.com/">http://www.google.com</a> 时，浏览器则直接访问 <a target="_blank" rel="noopener" href="https://www.google.com/">https://www.google.com</a> 了，而不需要再去访问服务器，然后又一次拿到响应。这就是永久重定向的意思</p>
<h2 id="302-Found-x2F-临时重定向"><a href="#302-Found-x2F-临时重定向" class="headerlink" title="302 Found&#x2F;临时重定向"></a><strong>302 Found&#x2F;临时重定向</strong></h2><p>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，除非有 Cache-Control 或者是 Expires 说明情况下才可以进行缓存，否则都是不可以缓存的。在不缓存的情况下（默认情况），下一次访问原地址时，浏览器应该继续访问服务器。</p>
<p>302 一个例子就是上述说的用户访问用户中心的例子，在未登录的情况下，需要重定向至登录页面，而在已经登录的情况下，则需要直接显示已登录后用户中心的页面。这次每一次访问都需要进行判断，所以只能是临时重定向。</p>
<p>一、状态码——302</p>
<p>    RFC1945(<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc1945#page-34">http://tools.ietf.org/html/rfc1945#page-34</a>)，也就是HTTP1.0在介绍302时说，如果客户端发出POST请求后，收到服务端的302状态码，那么不能自动的向新的URI发送重复请求，必须跟用户确认是否该重发，因为第二次POST时，环境可能已经发生变化（嗯，POST方法不是幂等的），POST操作会不符合用户预期。但是，很多浏览器（user agent我描述为浏览器以方便介绍）在这种情况下都会把POST请求变为GET请求。</p>
<p>    RFC2616(<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc2616#section-10.3.3">http://tools.ietf.org/html/rfc2616#section-10.3.3</a>)，也就是HTTP1.1在介绍302时说，如果客户端发出非GET、HEAD请求后，收到服务端的302状态码，那么就不能自动的向新URI发送重复请求，除非得到用户的确认。（又是-,-）但是，很多浏览器都把302当作303处理了（注意，303是HTTP1.1才加进来的，其实从HTTP1.0进化到HTTP1.1，浏览器什么都没动），它们获取到HTTP响应报文头部的Location字段信息，并发起一个GET请求。</p>
<p>二、状态码——303和307</p>
<p>    从上面的介绍可以知道，HTTP1.1和HTTP1.0的302状态码意义是一样的，浏览器对它的处理也是一样的。POST方法的重定向在未询问用户的情况下就变成GET，这种不符合文档规范的问题依然存在。实践在前而文档在后，HTTP1.1把这种POST变GET的行为纳入了RFC文档：HTTP1.1新加入303和307状态码。</p>
<p>    文档中规定303状态码的响应，也就是上边提到的现在浏览器对302状态码的处理：POST重定向为GET。</p>
<p>    HTTP1.1文档中307状态码则相当于HTTP1.0文档中的302状态码，当客户端的POST请求收到服务端307状态码响应时，需要跟用户询问是否应该在新URI上发起POST方法，也就是说，307是不会把POST转为GET的。</p>
<p>三、总结</p>
<p>    303和307是HTTP1.1新加的服务器响应文档的状态码，它们是对HTTP1.0中的302状态码的细化，主要用在对非GET、HEAD方法的响应上。文档规定：<strong>浏览器对303状态码的处理跟原来浏览器对HTTP1.0的302状态码的处理方法一样；浏览器对307状态码处理则跟原来HTTP1.0文档里对302的描述一样。�</strong>�</p>
<p>    303和307的存在，归根结底是由于POST方法的非幂等属性引起的。</p>
<p><strong>4.4 4XX 客户端错误�</strong>�</p>
<p>4XX 的响应结果表明客户端是发生错误的原因所在。 </p>
<p><strong>4.4.1 400 Bad Request</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/c8e2b7669e12b9ebf399c805dbc2c866.png" alt="c8e2b7669e12b9ebf399c805dbc2c866.png"></strong></p>
<p>在 ajax 请求后台数据时比较常见。产生 HTTP 400 错误的原因有：</p>
<blockquote>
<p>1、前端提交数据的<strong>字段名称</strong>或者是<strong>字段类型</strong>和后台的实体类不一致，导致无法封装；如需要 int，客户端传的是 String</p>
<p>2、前端提交的到后台的数据应该是 json 字符串类型，而前端没有将对象转化为字符串类型；</p>
</blockquote>
<p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求 的内容后再次发送请求。</p>
<p><strong>4.4.2 401 Unauthorized</strong></p>
<h2 id="Basic认证简介"><a href="#Basic认证简介" class="headerlink" title="Basic认证简介"></a>Basic认证简介</h2><p>在网络活动中，身份认证是非常重要的一环。Basic身份认证，是HTTP 1.0中引入的认证方案之一。虽然方案比较古老，同时存在安全缺陷，但由于实现简单，至今仍有不少网站在使用它。</p>
<p>本文通过实例，介绍Basic认证协议是如何实现的。同时，探讨Basic认证存在的安全缺陷。最后，附上Basic认证的服务端代码。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Basic认证通过核对用户名、密码的方式，来实现用户身份的验证。</p>
<p>Basic认证中，最关键的4个要素：</p>
<ol>
<li>userid：用户的id。也就是我们常说的用户名。</li>
<li>password：用户密码。</li>
<li>realm：“领域”，</li>
</ol>
<p>同一个server，访问受限的资源多种多样，比如资金信息、机密文档等。可以针对不同的资源定义不同的 realm，并且只允许特定的用户访问。</p>
<p>跟Linux下的账户、分组体系很像，如下例子所示。</p>
<p>%!(EXTRA markdown.ResourceType&#x3D;, string&#x3D;, string&#x3D;)</p>
<h2 id="Basic认证实例"><a href="#Basic认证实例" class="headerlink" title="Basic认证实例"></a>Basic认证实例</h2><p>下面通过实例来讲解Basic认证是如何实现的，一共分4个步骤。假设：</p>
<ol>
<li>用户访问的资源：&#x2F;protected_docs</li>
<li>用户名、密码：chyingp、123456</li>
</ol>
<h3 id="步骤1：用户访问受限资源"><a href="#步骤1：用户访问受限资源" class="headerlink" title="步骤1：用户访问受限资源"></a>步骤1：用户访问受限资源</h3><p>如下，用户访问受限资源 &#x2F;protected_docs。请求报文如下：</p>
<p>GET &#x2F;protected_docs HTTP&#x2F;1.1</p>
<p>Host: 127.0.0.1:3000</p>
<h3 id="步骤2：服务端返回401要求身份认证"><a href="#步骤2：服务端返回401要求身份认证" class="headerlink" title="步骤2：服务端返回401要求身份认证"></a>步骤2：服务端返回401要求身份认证</h3><p>服务端发现 &#x2F;protected_docs 为受限资源，于是向用户发送401状态码，要求进行身份认证。</p>
<p>HTTP&#x2F;1.1 401 Unauthorized</p>
<p>WWW-Authenticate: Basic realm&#x3D;protected_docs</p>
<p>响应首部中，通过WWW-Authenticate告知客户端，认证的方案是basic。同时以realm告知认证的范围。</p>
<p>WWW-Authenticate: Basic realm&#x3D;&lt;需要保护资源的范围&gt;</p>
<h3 id="步骤3：用户发送认证请求"><a href="#步骤3：用户发送认证请求" class="headerlink" title="步骤3：用户发送认证请求"></a>步骤3：用户发送认证请求</h3><p>用户收到服务端响应后，填写用户名、密码，然后向服务端发送认证请求。</p>
<p>%!(EXTRA markdown.ResourceType&#x3D;, string&#x3D;, string&#x3D;)</p>
<p>以下为请求报文。Authorization请求首部中，包含了用户填写的用户名、密码。</p>
<p>GET &#x2F;protected_docs HTTP&#x2F;1.1</p>
<p>Authorization: Basic Y2h5aW5ncDoxMjM0NTY&#x3D;</p>
<p>Authorization首部的格式为Basic base64(userid:password)。</p>
<h3 id="步骤4：服务端验证请求"><a href="#步骤4：服务端验证请求" class="headerlink" title="步骤4：服务端验证请求"></a>步骤4：服务端验证请求</h3><p>服务端收到用户的认证请求后，对请求进行验证。验证包含如下步骤：</p>
<ol>
<li>根据用户请求资源的地址，确定资源对应的realm。</li>
<li>解析 Authorization 请求首部，获得用户名、密码。</li>
<li>判断用户是否有访问该realm的权限。</li>
<li>验证用户名、密码是否匹配。</li>
</ol>
<p>一旦上述验证通过，则返回请求资源。如果验证失败，则返回401要求重新认证，或者返回403（Forbidden）。</p>
<p>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示 用 户认证失败。 返回含有 401 的响应必须包含一个适用于被请求资源的 WWWAuthenticate 首部用以质询（challenge）用户信息。当浏览器初次接收 到 401 响应，会弹出认证用的对话窗口</p>
<p><strong>4.4.3 403 Forbidden</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/40d7ef64e4b1f8eb9ce8bc2225bf8123.png" alt="40d7ef64e4b1f8eb9ce8bc2225bf8123.png"></strong></p>
<p>该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要 给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分 对原因进行描述，这样就能让用户看到了 。</p>
<p><strong>4.4.4 404 Not Found</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/ed170f9245119dc3520a8652abe72c81.png" alt="ed170f9245119dc3520a8652abe72c81.png"></strong></p>
<p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p>
<p><strong>4.5 5XX 服务器错误�</strong>�</p>
<p>5XX 的响应结果表明服务器本身发生错误</p>
<p><strong>4.5.1 500 Internal Server Error</strong></p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/97506ad157dd71356f1229f0707f49cb.png" alt="97506ad157dd71356f1229f0707f49cb.png"></p>
<p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</p>
<p><strong>4.5.2 503 Service Unavailable</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/2d58cb7eafeb2c1c5696c293494d7f65.png" alt="2d58cb7eafeb2c1c5696c293494d7f65.png"></strong></p>
<p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。</p>
<p><strong>6.3 HTTP&#x2F;1.1 首部字段</strong></p>
<p><strong>1. Cache-Control</strong></p>
<h3 id="什么是HTTP缓存"><a href="#什么是HTTP缓存" class="headerlink" title="什么是HTTP缓存"></a><strong>什么是HTTP缓存</strong></h3><p>HTTP 缓存可以说是HTTP性能优化中简单高效的一种优化方式了，缓存是一种保存资源副本并在下次请求时直接使用该副本的技术，当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。</p>
<p>一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，节省网络流量，并且由于缓存文件可以重复利用，降低网络负荷，提高客户端响应。</p>
<p>所以，<strong>学会利用HTTP缓存是很有必要的</strong></p>
<p>在此，我会向大家系统的介绍HTTP缓存机制，期望对各位正确的理解HTTP缓存有所帮助</p>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a><strong>缓存策略</strong></h3><p>HTTP 缓存主要是通过请求和响应报文头中的对应 Header 信息，来控制缓存的策略。</p>
<p>响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag。</p>
<p>HTTP缓存的类型很多，根据是否需要重新向服务器发起请求来分类包括两种：<strong>强制缓存</strong> 和 <strong>对比缓存</strong></p>
<p>假设浏览器有一个缓存数据库用于本地缓存，先看看浏览器请求资源的情况：</p>
<p>%!(EXTRA markdown.ResourceType&#x3D;, string&#x3D;, string&#x3D;)</p>
<p>强制缓存：</p>
<p>在浏览器已经缓存数据的情况下，使用强制缓存去请求数据的流程是这样的：</p>
<p>%!(EXTRA markdown.ResourceType&#x3D;, string&#x3D;, string&#x3D;)</p>
<p>从流程图可以看到，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，不需要再请求服务器，那么浏览器是如何判断缓存数据是否失效呢？</p>
<p>对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires&#x2F;Cache-Control）：</p>
<ul>
<li>Expires：</li>
</ul>
<p>Expires是HTTP1.0的产物了，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。但是很多网站还是对它做了兼容。它的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。</p>
<p>但有一个问题是到期时间是由服务端生成的，如果客户端时间跟服务器时间不一致，这就会导致缓存命中的误差。</p>
<p>在HTTP 1.1 的版本，Expires被Cache-Control替代。</p>
<ul>
<li>Cache-Control：</li>
</ul>
<p>Cache-Control是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。</p>
<blockquote>
<p>（1） max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；</p>
<p>（2） s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；</p>
<p>（3）public：指示响应可被任何缓存区缓存；</p>
<p>（4）private：只能针对个人用户，而不能被代理服务器缓存；</p>
<p>（5）no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到 请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误 以为是响应不被缓存。实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。</p>
<p>（6）no-store：禁止一切缓存（这个才是响应不被缓存的意思）。</p>
</blockquote>
<h4 id="对比缓存："><a href="#对比缓存：" class="headerlink" title="对比缓存："></a><strong>对比缓存：</strong></h4><p>在浏览器已经缓存数据的情况下，使用对比缓存去请求数据的流程是这样的：</p>
<p>%!(EXTRA markdown.ResourceType&#x3D;, string&#x3D;, string&#x3D;)</p>
<p>有同学可能会问，基于对比缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？</p>
<p>这个问题，我们现在来探讨一下。</p>
<p>对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。</p>
<p>浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给浏览器，浏览器将二者备份至缓存数据库中。</p>
<p>当浏览器再次请求数据时，浏览器将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。</p>
<p>对比缓存，响应header中会有两个字段来标明规则</p>
<ul>
<li>Last-Modified &#x2F; If-Modified-Since</li>
</ul>
<p>服务器响应请求时，会通过Last-ModifiedHTTP头告诉浏览器资源的最后修改时间，浏览器本地对资源缓存起来，之后再请求的时候，会带上一个HTTP头If-Modified-Since，这个值就是服务器上一次给的Last-Modified的时间，服务器会拿着浏览器传过来的时间比对资源当前最后的修改时间，如果大于If-Modified-Since，则说明资源修改过了，浏览器不能再使用缓存，服务器重新一份完整的资源浏览器，否则浏览器可以继续使用缓存，并返回304状态码</p>
<ul>
<li>Etag &#x2F; If-None-Match（优先级高于Last-Modified &#x2F; If-Modified-Since）</li>
</ul>
<p>服务器响应请求时，通过EtagHTTP头部告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定），浏览器再次请求时，就会带上一个头If-None-Match，这个值就是服务器上一次给的Etag的值，服务器比对一下资源当前的Etag是否跟If-None-Match一致，不一致则说明资源修改过了，浏览器不能再使用缓存，否则浏览器可以继续使用缓存，并返回304状态码</p>
<p>值得注意的是：<strong>Etag 的校验优先级高于 Last-Modified</strong></p>
<h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a><strong>Pragma</strong></h3><p>当该字段值为“no-cache”的时候_（事实上现在RFC中也仅标明该可选值）_，会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行。Pragma属于通用首部字段，在客户端上使用时，常规要求我们往html上加上这段meta元标签（仅对该页面有效，对页面上的资源无效）：</p>
<p>&lt;meta http-equiv&#x3D;”Pragma” content&#x3D;”no-cache”&gt;</p>
<p>它告诉浏览器每次请求页面时都不要读缓存，都得往服务器发一次请求才行</p>
<p><strong>Connection</strong></p>
<p>管理持久连接</p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/00c50b8ec40ffe2bdc4221938a68ad5d.png" alt="00c50b8ec40ffe2bdc4221938a68ad5d.png"></p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/d3c63a438022740bc32b362c928ab0a4.png" alt="d3c63a438022740bc32b362c928ab0a4.png"></p>
<p>HTTP&#x2F;1.1 版本的默认连接都是持久连接。为此，客户端会在持 久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。</p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/a627503d9d63f5e4cdfd85421b115770.png" alt="a627503d9d63f5e4cdfd85421b115770.png"></p>
<p>HTTP&#x2F;1.1 之前的 HTTP 版本的默认连接都是非持久连接。为 此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。 如上图①所示，客户端发送请求给服务器时，服务器端会像上图 ②那样加上首部字段 Keep-Alive 及首部字段 Connection 后返回 响应。</p>
<p><strong>Date</strong> </p>
<p>首部字段 Date 表明创建 HTTP 报文的日期和时间。</p>
<p><strong>Trailer</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/9ae74a67e5b859b9bbefe3ffae679883.png" alt="9ae74a67e5b859b9bbefe3ffae679883.png"></strong></p>
<p>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该 首部字段可应用在 HTTP&#x2F;1.1 版本分块传输编码时。</p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/3d39f222d8aaa43661186787f6c2c7a5.png" alt="3d39f222d8aaa43661186787f6c2c7a5.png"></p>
<p>以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后 （分块长度 0 之后）出现了首部字段 Expires。</p>
<p><strong>Transfer-Encoding</strong></p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/19f69a7169e80253266bf6f59665a11c.png" alt="19f69a7169e80253266bf6f59665a11c.png"></p>
<p>首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。 HTTP&#x2F;1.1 的传输编码方式仅对分块传输编码有效。</p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/fc1499bfba15b45e48fd8812faf150f9.png" alt="fc1499bfba15b45e48fd8812faf150f9.png"></p>
<p>以上用例中，正如在首部字段 Transfer-Encoding 中指定的那样，有效 使用分块传输编码，且分别被分成 3312 字节和 914 字节大小的分块 数据。</p>
<p><strong>Accept</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/d565a6b0df5fae6f64d0f551811821cc.png" alt="d565a6b0df5fae6f64d0f551811821cc.png"></strong></p>
<p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用type&#x2F;subtype 这种形式，一次指定多种媒体类型。 下面我们试举几个媒体类型的例子</p>
<p>文本文件 text&#x2F;html, text&#x2F;plain, text&#x2F;css … application&#x2F;xhtml+xml, application&#x2F;xml … </p>
<p>图片文件 image&#x2F;jpeg, image&#x2F;gif, image&#x2F;png … </p>
<p>视频文件 video&#x2F;mpeg, video&#x2F;quicktime … </p>
<p>应用程序使用的二进制文件 application&#x2F;octet-stream, application&#x2F;zip …</p>
<p>比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定 image&#x2F;png，而指定可处理的 image&#x2F;gif 和 image&#x2F;jpeg 等图片类型。 若想要给显示的媒体类型增加优先级，则使用 q&#x3D; 来额外表示权重值 1，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点 后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q&#x3D;1.0。 当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。</p>
<p><strong>Accept-Charset</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/20359195cbc0bd0c9547d41a5fbfd7b2.png" alt="20359195cbc0bd0c9547d41a5fbfd7b2.png"></strong></p>
<p>Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及 字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字 段 Accept 相同的是可用权重 q 值来表示相对优先级。</p>
<p><strong>Accept-Encoding</strong></p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/b1525971930c5895922682dd0e8607d6.png" alt="b1525971930c5895922682dd0e8607d6.png"></p>
<p><strong>Accept-Language</strong></p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/61f1a4efe4062b5602586092ff49a5b4.png" alt="61f1a4efe4062b5602586092ff49a5b4.png"></p>
<p>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然 语言集（指中文或英文等），以及自然语言集的相对优先级。可一次 指定多种自然语言集。 和 Accept 首部字段一样，按权重值 q 来表示相对优先级。在上述图 例中，客户端在服务器有中文版资源的情况下，会请求其返回中文版 对应的响应，没有中文版时，则请求返回英文版响应。</p>
<p><strong>Authorization</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/f4a64de0494b096f0ba7eceedaf9881b.png" alt="f4a64de0494b096f0ba7eceedaf9881b.png"></strong></p>
<p>首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证 书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。</p>
<p><strong>If-Match</strong></p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/7b5dc1467f328da9b78803606be65a26.png" alt="7b5dc1467f328da9b78803606be65a26.png"></p>
<p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/56d37833b9f302a857c4578eacd0d500.png" alt="56d37833b9f302a857c4578eacd0d500.png"></p>
<p>首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用 的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。（请参 照本章有关首部字段 ETag 的说明） 服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致 时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响 应。 还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务 器将会忽略 ETag 的值，只要资源存在就处理请求。</p>
<p><strong>If-Modified-Since</strong></p>
<p>首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 IfModified-Since 字段值早于资源的更新时间，则希望能处理该请求。 而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源 都没有过更新，则返回状态码 304 Not Modified 的响应。</p>
<p><strong>If-None-Match</strong></p>
<p>首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与 请求资源的 ETag 不一致时，它就告知服务器处理该请求。</p>
<p><strong>If-Range</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/debf84030561c988029a028e9b252957.png" alt="debf84030561c988029a028e9b252957.png"></strong></p>
<p>首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 IfRange 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一 致时，则作为范围请求处理。反之，则返回全体资源。</p>
<p><strong>If-Unmodified-Since</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/9f89f80c46b403e8aee89d9854b65caf.png" alt="9f89f80c46b403e8aee89d9854b65caf.png"></strong></p>
<p>首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相 反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定 的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定 日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应 返回。</p>
<p><strong>Range</strong></p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/ae956476fc03a44076733adda11bd1a2.png" alt="ae956476fc03a44076733adda11bd1a2.png"></p>
<p>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服 务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。 接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状 态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返 回状态码 200 OK 的响应及全部资源。</p>
<p><strong>Referer</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/ceb683616ace47388b62a276fd72a3a0.png" alt="ceb683616ace47388b62a276fd72a3a0.png"></strong></p>
<p><strong>User-Agent</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/39f8249a2bb68ca24cdf56b5985e8340.png" alt="39f8249a2bb68ca24cdf56b5985e8340.png"></strong></p>
<p>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传 达给服务器。</p>
<p><strong>Accept-Ranges</strong></p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/0aa2c8864ab435d68e96f045cbdc1e32.png" alt="0aa2c8864ab435d68e96f045cbdc1e32.png"></p>
<p>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请 求，以指定获取服务器端某个部分的资源。 可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则 指定其为 none。</p>
<p><strong>Age</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/feda461972bb96693e37061231301b1a.png" alt="feda461972bb96693e37061231301b1a.png"></strong></p>
<p>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值 的单位为秒。</p>
<p><strong>ETag</strong></p>
<p>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串 形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。</p>
<p>另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有 统一的算法规则，而仅仅是由服务器来分配。</p>
<p>强 ETag 值和弱 Tag 值 </p>
<p>ETag 中有强 ETag 值和弱 ETag 值之分。 </p>
<p>强 ETag 值   不论实体发生多么细微的变化都会改变其值。</p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/a97c2fe50b4adee8739bb9af34893770.png" alt="a97c2fe50b4adee8739bb9af34893770.png"></p>
<p>弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产 生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W&#x2F;。</p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/768b07b1f7416ce32f84737ac9c0aaba.png" alt="768b07b1f7416ce32f84737ac9c0aaba.png"></p>
<p><strong>Location</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/f8e3cf840520acd6cfefe0f8c4f8c56c.png" alt="f8e3cf840520acd6cfefe0f8c4f8c56c.png"></strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/75525a6aedde277c147e54a927d1be87.png" alt="75525a6aedde277c147e54a927d1be87.png"></strong></p>
<p><strong>Retry-After</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/a2fc642e9f11af444196f4d8ea76a2fa.png" alt="a2fc642e9f11af444196f4d8ea76a2fa.png"></strong></p>
<p>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要 配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使 用。 字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24 GMT 等格式），也可以是创建响应后的秒数。</p>
<p><strong>Server</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/12885b891d82d69da4dd20b854cd2095.png" alt="12885b891d82d69da4dd20b854cd2095.png"></strong></p>
<p><strong>WWW-Authenticate</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/0bf6162d5d4eb140ac90094b607250d4.png" alt="0bf6162d5d4eb140ac90094b607250d4.png"></strong></p>
<p>首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端 适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和 带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中， 肯定带有首部字段 WWW-Authenticate。 上述示例中，realm 字段的字符串是为了辨别请求 URI 指定资源所受 到的保护策略。</p>
<p><strong>Allow</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/dfac4ebd1d390909779af9e3ef24ed40.png" alt="dfac4ebd1d390909779af9e3ef24ed40.png"></strong></p>
<p>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所 有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支 持的 HTTP 方法写入首部字段 Allow 后返回。</p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/1db173c70e9ecc5135c8581d520dd68a.png" alt="1db173c70e9ecc5135c8581d520dd68a.png"></p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/5016d62b0a654838378984adf53bc12e.png" alt="5016d62b0a654838378984adf53bc12e.png"></p>
<p><strong>Content-MD5</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/8e91a8c9dbff314ae8c3aa05ee3e2bbf.png" alt="8e91a8c9dbff314ae8c3aa05ee3e2bbf.png"></strong></p>
<p>      首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。 对报文主体执行 MD5 算法获得的 128 位二进制数，再通过 Base64 编 码后将结果写入 Content-MD5 字段值。由于 HTTP 首部无法记录二进 制值，所以要通过 Base64 编码处理。为确保报文的有效性，作为接 收方的客户端会对报文主体再执行一次相同的 MD5 算法。计算出的 值与字段值作比较后，即可判断出报文主体的准确性。</p>
<p>      采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出 恶意篡改。其中一个原因在于，内容如果能够被篡改，那么同时意味 着 Content-MD5 也可重新计算然后被篡改。所以处在接收阶段的客户 端是无法意识到报文主体以及首部字段 Content-MD5 是已经被篡改过 的。</p>
<p><strong>Content-Range</strong></p>
<p><strong><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/d2398f54b331b1b802aa433b87966dd3.png" alt="d2398f54b331b1b802aa433b87966dd3.png"></strong></p>
<p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客 户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为 单位，表示当前发送部分及整个实体大小。</p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/477bc20c822cb09fc498d3b142781aa1.png" alt="477bc20c822cb09fc498d3b142781aa1.png"></p>
<p>首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字 段 Accept 一样，字段值用 type&#x2F;subtype 形式赋值。</p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/340b2d5267e9e0d2fe8c1ea46bded206.png" alt="340b2d5267e9e0d2fe8c1ea46bded206.png"></p>
<p>首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接 收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过 指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求 资源。 源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写 入与首部字段 Date 相同的时间值。 但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字 段 Expires，会优先处理 max-age 指令。</p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/c17ef9a89e27c2e871bab6e78cf56bca.png" alt="c17ef9a89e27c2e871bab6e78cf56bca.png"></p>
<p>首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个 值就是 Request-URI 指定资源被修改的时间。</p>
<p><strong>HTTP cookie详解�</strong>�</p>
<p><strong>1.cookie的起源�</strong>�</p>
<p>           早期Web开发面临的最大问题之一是如何管理状态。简言之，服务器端没有办法知道两个请求是否来自于同一个浏览器。那时的办法是在请求的页面中插入一个token，并且在下一次请求中将这个token返回（至服务器）。这就需要在form中插入一个包含token的隐藏表 单域，或着在URL的qurey字符串中传递该token。这两种办法都强调手工操作并且极易出错。 Lou Montulli,那时是网景通讯的一个雇员，被认为在1994年将“magic cookies”的概念应用到了web通讯中。他意图解决的是web中的购物车，现在所有购物网站都依赖购物车。他的最早的说明文档提供了一些cookie工作原理的基本信息该文档在RFC2109中被规范化（这是 所有浏览器实现cookie的参考依据），并且最终逐步形成了REF2965.Montulli最终也被授予了关于cookie的美国专利。网景浏览器在它的第一个版本中就开始支持cookie，并且当前所有web浏览器都支持cookie。</p>
<p><strong>2.cookie是什么</strong> </p>
<p>          坦白的说，一个cookie就是存储在用户主机浏览器中的一小段文本文件。Cookies是纯文本形式，它们不包含任何可执行代码。一个Web页面或服务器告之浏览器来将这些信息存储并且基于一系列规则在之后的每个请求中都将该信息返回至服务器。Web服务器之后可以利 用这些信息来标识用户。多数需要登录的站点通常会在你的认证信息通过后来设置一个cookie，之后只要这个cookie存在并且合法，你就可以自由的浏览这个站点的所有部分。再次，cookie只是包含了数据，就其本身而言并不有害。</p>
<p><strong>3.创建cookie�</strong>�</p>
<p>  3.1 Set-Cookie消息头 </p>
<p>            通过HTTP的Set-Cookie消息头，Web服务器可以指定存储一个cookie。Set-Cookie消息的格式如下面的字符串（中括号中的部分都是可选的） </p>
<p>          Set-Cookie:value [ ;expires&#x3D;date][ ;domain&#x3D;domain][ ;path&#x3D;path][ ;secure] </p>
<p>           消息头的第一部分，value部分，通常是一个name&#x3D;value格式的字符串。事实上，原始手册指示这是应该使用的格式，但是浏览器对cookie的所有值并不会按此格式校验。实际上，你可以指定一个不包含等号的字符串并且它同样会被存储。然而，通常性的使用方式是以 name&#x3D;value的格式（并且多数的接口只支持该格式）来指定cookie的值。 </p>
<p>           当一个cookie存在，并且可选条件允许的话，该cookie的值会在接下来的每个请求中被发送至服务器。cookie的值被存储在名为Cookie的HTTP消息头中，并且只包含了cookie的值，其它的选项全部被去除。</p>
<p>            例如： Cookie : value 通过Set-Cookie指定的选项只是应用于浏览器端，一旦选项被设置后便不会被服务器重新取回。cookie的值与Set-Cookie中指定的值是完全一样的字符串；对于这些值不会有更近一步的解析或转码操作。如果在指定的请求中有多个cookie，那么它们会被分号和空格分 开，</p>
<p>           例如： Cookie:value1 ; value2 ; name1&#x3D;value1</p>
<p>     3.2 有效期限(Expires） </p>
<p>           紧跟cookie值后面的每个选项都以分号和空格分割，并且每个选项都指定cookie何时应该被发送到服务器。第一个选项是expires，其指定了cookie何时不会再被发送到服务器端的，因此该cookie可能会被浏览器删掉。该选项所对应的值是一个格式为Wdy,DD-Mon--YYYY HH:MM:SS GMT的值，</p>
<p>               例如： Set-Cookie:name&#x3D;Nicholas;expires&#x3D;Sat, 02 May 2009 23:38:25 GMT 在没有expires选项时，cookie的寿命仅限于单一的会话中。浏览器的关闭意味这一次会话的结束，所以会话cookie只存在于浏览器保持打开的状态之下。这就是为什么当你登录到一个web应用时经常看到一个checkbox，询问你是否选择存储你的登录信息：如果你选择是 的话，那么一个expires选项会被附加到登录的cookie中。如果expires选项设置了一个过去的时间点，那么这个cookie会被立即删除</p>
<p>     3.3 Domain和Path</p>
<p>1.cookie中的domain代表的是cookie所在的域，默认情况下就是请求的域名，例如请求<a target="_blank" rel="noopener" href="http://www.server1.com/files/hello">http://www.server1.com/files/hello</a>, 那么响应中的set-Cookie默认会使用<a target="_blank" rel="noopener" href="http://www.server1.com/">www.server1.com</a>作为cookie的domain，在浏览器中也是按照domain来组织cookie的。 我们可以在响应中设置cookie的domain为其他域，但是浏览器并不会去保存这些domain为其他域的cookie。</p>
<p>2.cookie中的path能够进一步的控制cookie的访问，当path&#x3D;&#x2F;; 当前域的所有请求都可以访问到这个cookie。 如果path设为其他值，比如path&#x3D;&#x2F;test,那么只有&#x2F;test下面的请求可以访问到这个cookie。</p>
<p>纸上得来终觉浅，绝知此事要躬行</p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/b20e86a813b374bd9e1de4426aa1fe32.png" alt="b20e86a813b374bd9e1de4426aa1fe32.png"></p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/c7f3b4f012330beb16f75eddcd8f717d.png" alt="c7f3b4f012330beb16f75eddcd8f717d.png"></p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/194eecc9c4e9a1870eb6f9acd67b56e2.png" alt="194eecc9c4e9a1870eb6f9acd67b56e2.png"></p>
<p>我们从浏览器的保存情况中可以看出： 1. 浏览器是按照domain域来组织cookie的。</p>
<p>　　　　　　　　　　　　　　　　　 2. domain的默认值为请求的域名。</p>
<p>　　　　　　　　　　　　　　　　　 3. path的默认值为请求的上一层目录（请求为：**&#x2F;hello&#x2F;test&#x2F;test1**&#x2F;test2.html, path为&#x2F;hello&#x2F;test&#x2F;test1）</p>
<p>更改cookie的domain和path值</p>
<p>我们可以改变cookie的domain和path的值，看看会发生什么。</p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/1f4cd260db122a01388d540e1122a616.png" alt="1f4cd260db122a01388d540e1122a616.png"></p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/5b30c1d24faf0926d0d2d663e4661d1e.png" alt="5b30c1d24faf0926d0d2d663e4661d1e.png"></p>
<p><img src="https://sssjody.oss-cn-beijing.aliyuncs.com/img66/5d6f64aaa1323ad6bbe52d08f64b84c8.png" alt="5d6f64aaa1323ad6bbe52d08f64b84c8.png"></p>
<p>我们看到浏览器仅仅保存了ageCookie，并没有保存nameCookie，实际上就是因为浏览器不会从一个响应中保存其他域名的cookie。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/08/%E5%9B%BE%E8%A7%A3HTTP-2/" data-id="cl2x5p31e002rmkvj1y4bbvbj" data-title="图解HTTP---2" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/05/08/%E7%BD%91%E7%BB%9C%E5%B1%82/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          网络层-待更新
        
      </div>
    </a>
  
  
    <a href="/2022/05/08/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">内存结构</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-se/" rel="tag">java se</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">jvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/java-se/" style="font-size: 12px;">java se</a> <a href="/tags/jvm/" style="font-size: 12px;">jvm</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/redis/" style="font-size: 20px;">redis</a> <a href="/tags/spring/" style="font-size: 16px;">spring</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 18px;">多线程</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 14px;">计算机网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/08/%E5%8F%8D%E5%B0%84/">反射</a>
          </li>
        
          <li>
            <a href="/2022/05/08/%E6%B3%9B%E5%9E%8B/">泛型</a>
          </li>
        
          <li>
            <a href="/2022/05/08/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">深拷贝和浅拷贝</a>
          </li>
        
          <li>
            <a href="/2022/05/08/StringTable/">StringTable</a>
          </li>
        
          <li>
            <a href="/2022/05/08/HTTPS/">HTTPS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>